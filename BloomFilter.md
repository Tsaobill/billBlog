### 介绍

布隆过滤器（Bloom Filter）是1970年由布隆提出的。本质上是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 **“某样东西一定不存在或者可能存在”**。它实际上是一个很长的二进制向量(位图)和一系列随机映射函数（哈希函数）。
它的优点是空间效率和查询时间都远远超过一般的算法（时间复杂度O(1)），缺点是有一定的误识别率和删除困难。

当要检索的的数据量过大，内存不足且检索速度很慢时，可以考虑使用布隆过滤器，但需要忍受一定的失误率。

### 原理

布隆过滤器其中重要的实现就是位图的实现，也就是位数组，并且在这个数组中每一个位置只占有1个bit，而每个bit只有0和1两种状态。如上图bitarray所示！bitarray也叫bitmap，大小也就是布隆过滤器的大小。

假设一种有k个哈希函数，且每个哈希函数的输出范围都大于m，接着将输出值对k取余（%m）,就会得到k个[0, m-1]的值，由于每个哈希函数之间相互独立，因此这k个数也相互独立，最后将这k个数对应到bitarray上并标记为1（涂黑）。

等判断时，将输入对象经过这k个哈希函数计算得到k个值，然后判断对应bitarray的k个位置是否都为1，**如果有一个不为1，那么这个输入对象则不在这个集合中，也就不是黑名单了！如果都是1，那说明在集合中，但有可能会误**，由于当输入对象过多，而集合也就是bitarray过小，则会出现大部分为1的情况，那样就容易发生误判！因此使用布隆过滤器是需要容忍错误率的，即使很低很低！

### 布隆过滤器重要参数计算

通过上面的描述，我们可以知道，如果输入量过大，而bitarray空间的大小又很小，那么误判率就会上升。那么bitarray空间大小怎么确定呢？

假设输入对象个数为n，bitarray大小（也就是布隆过滤器大小）为m，所容忍的误判率p，哈希函数的个数k。计算公式如下：（**小数向上取整**）

![img](https://picb.zhimg.com/80/v2-fc1fb96508a363b17d1bb7737dc51e54_1440w.jpg)



**注意：由于我们计算的m和k可能是小数，那么需要经过向上取整，此时需要重新计算误判率p！**

假设一个网页黑名单有URL为100亿，每个样本为64B，失误率为0.01%，经过上述公式计算后，需要布隆过滤器大小为25GB，这远远小于使用哈希表的640GB的空间。

并且由于是通过hash进行查找的，所以基本都可以在O(1)的时间完成！

### 关于删除操作

传统的布隆过滤器并不支持删除操作。但是名为 Counting Bloom filter 的变种可以用来测试元素计数个数是否绝对小于某个阈值，它支持元素删除。可以参考文章 [Counting Bloom Filter 的原理和实现](https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1136056)

### 实际应用

1、 如一个存储黑名单的网站的查询，可以先使Bloom Filter过滤，再执行查询。

2、 常见的适用常见有，利用布隆过滤器减少磁盘 IO 或者网络请求，因为一旦一个值必定不存在的话，我们可以不用进行后续昂贵的查询请求。

另外，既然你使用布隆过滤器来加速查找和判断是否存在，那么性能很低的哈希函数不是个好选择，推荐 MurmurHash、Fnv 这些。

**关于Redis缓存中大Value拆分**

Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中有时需要对体积庞大的布隆过滤器进行拆分。

拆分的形式方法多种多样，但是核心思想是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。

参考文献：https://zhuanlan.zhihu.com/p/43263751

